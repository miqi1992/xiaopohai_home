## 额外资源

* [effective-java-2nd 中文版 ](https://pan.baidu.com/s/1R6H9UHbFYubWWY9HrclZ2A)
* [effective-java-3rd 英文版 ](https://pan.baidu.com/s/1mJx5ZrOD_RPjf3ghQnBV5g)
* [effective-java-3rd 源代码](https://github.com/jbloch/effective-java-3e-source-code)



## 友情链接

 - [On Java 8中文版 - 即 thinking in java 第五版](https://github.com/LingCoder/OnJava8)

## 📚 高效 Java 第三版

### Chapter 2. Creating and Destroying Objects

- [01. 考虑使用静态工厂方法替代构造方法](book/effactive-java-3rd/01.%20考虑使用静态工厂方法替代构造方法.md)
- [02. 当构造方法参数过多时使用builder模式](book/effactive-java-3rd/02.%20当构造方法参数过多时使用builder模式.md)
- [03. 使用私有构造方法或枚类实现Singleton属性](book/effactive-java-3rd/03.%20使用私有构造方法或枚类实现Singleton属性.md)
- [04. 使用私有构造方法执行非实例化](book/effactive-java-3rd/04.%20使用私有构造方法执行非实例化.md)
- [05. 依赖注入优于硬连接资源(hardwiring resources)](book/effactive-java-3rd/05.%20依赖注入优于硬连接资源(hardwiring%20resources).md)
- [06. 避免创建不必要的对象](book/effactive-java-3rd/06.%20避免创建不必要的对象.md)
- [07. 消除过期的对象引用](book/effactive-java-3rd/07.%20消除过期的对象引用.md)
- [08. 避免使用Finalizer和Cleaner机制](book/effactive-java-3rd/08.%20避免使用Finalizer和Cleaner机制.md)
- [09. 使用try-with-resources语句替代try-finally语句](book/effactive-java-3rd/09.%20使用try-with-resources语句替代try-finally语句.md)

### Chapter 3. Methods Common to All Objects

- [10. 重写equals方法时遵守通用约定](book/effactive-java-3rd/10.%20重写equals方法时遵守通用约定.md)
- [11. 重写equals方法时同时也要重写hashcode方法](book/effactive-java-3rd/11.%20重写equals方法时同时也要重写hashcode方法.md)
- [12. 始终重写 toString 方法](book/effactive-java-3rd/12.%20始终重写%20toString%20方法.md)
- [13. 谨慎地重写 clone 方法](book/effactive-java-3rd/13.%20谨慎地重写%20clone%20方法.md)
- [14. 考虑实现Comparable接口](book/effactive-java-3rd/14.%20考虑实现Comparable接口.md)

### Chapter 4. Classes and Interfaces

- [15. 使类和成员的可访问性最小化](book/effactive-java-3rd/15.%20使类和成员的可访问性最小化.md)
- [16. 在公共类中使用访问方法而不是公共属性](book/effactive-java-3rd/16.%20在公共类中使用访问方法而不是公共属性.md)
- [17. 最小化可变性](book/effactive-java-3rd/17.%20最小化可变性.md)
- [18. 组合优于继承](book/effactive-java-3rd/18.%20组合优于继承.md)
- [19. 要么设计继承并提供文档说明，要么禁用继承](book/effactive-java-3rd/19.%20要么设计继承并提供文档说明，要么禁用继承.md)
- [20. 接口优于抽象类](book/effactive-java-3rd/20.%20接口优于抽象类.md)
- [21. 为后代设计接口](book/effactive-java-3rd/21.%20为后代设计接口.md)
- [22. 接口仅用来定义类型](book/effactive-java-3rd/22.%20接口仅用来定义类型.md)
- [23. 类层次结构优于标签类](book/effactive-java-3rd/23.%20类层次结构优于标签类.md)
- [24. 支持使用静态成员类而不是非静态类](book/effactive-java-3rd/24.%20支持使用静态成员类而不是非静态类.md)
- [25. 将源文件限制为单个顶级类](book/effactive-java-3rd/25.%20将源文件限制为单个顶级类.md)

### Chapter 5. Generics

- [26. 不要使用原始类型](book/effactive-java-3rd/26.%20不要使用原始类型.md)
- [27. 消除非检查警告](book/effactive-java-3rd/27.%20消除非检查警告.md)
- [28. 列表优于数组](book/effactive-java-3rd/28.%20列表优于数组.md)
- [29. 优先考虑泛型](book/effactive-java-3rd/29.%20优先考虑泛型.md)
- [30. 优先使用泛型方法](book/effactive-java-3rd/30.%20优先使用泛型方法.md)
- [31. 使用限定通配符来增加API的灵活性](book/effactive-java-3rd/31.%20使用限定通配符来增加API的灵活性.md)
- [32. 合理地结合泛型和可变参数](book/effactive-java-3rd/32.%20合理地结合泛型和可变参数.md)
- [33. 优先考虑类型安全的异构容器](book/effactive-java-3rd/33.%20优先考虑类型安全的异构容器.md)

### Chapter 6. Enums and Annotations

- [34. 使用枚举类型替代整型常量](book/effactive-java-3rd/34.%20使用枚举类型替代整型常量.md)
- [35. 使用实例属性替代序数](book/effactive-java-3rd/35.%20使用实例属性替代序数.md)
- [36. 使用EnumSet替代位属性](book/effactive-java-3rd/36.%20使用EnumSet替代位属性.md)
- [37. 使用EnumMap替代序数索引](book/effactive-java-3rd/37.%20使用EnumMap替代序数索引.md)
- [38. 使用接口模拟可扩展的枚举](book/effactive-java-3rd/38.%20使用接口模拟可扩展的枚举.md)
- [39. 注解优于命名模式](book/effactive-java-3rd/39.%20注解优于命名模式.md)
- [40. 始终使用Override注解](book/effactive-java-3rd/40.%20始终使用Override注解.md)
- [41. 使用标记接口定义类型](book/effactive-java-3rd/41.%20使用标记接口定义类型.md)

### Chapter 7. Lambdas and Streams

- [42. lambda表达式优于匿名类](book/effactive-java-3rd/42.%20lambda表达式优于匿名类.md)
- [43. 方法引用优于lambda表达式](book/effactive-java-3rd/43.%20方法引用优于lambda表达式.md)
- [44. 优先使用标准的函数式接口](book/effactive-java-3rd/44.%20优先使用标准的函数式接口.md)
- [45. 明智审慎地使用Stream](book/effactive-java-3rd/45.%20明智审慎地使用Stream.md)
- [46. 优先考虑流中无副作用的函数](book/effactive-java-3rd/46.%20优先考虑流中无副作用的函数.md)
- [47. 优先使用Collection而不是Stream来作为方法的返回类型](book/effactive-java-3rd/47.%20优先使用Collection而不是Stream来作为方法的返回类型.md)
- [48. 谨慎使用流并行](book/effactive-java-3rd/48.%20谨慎使用流并行.md)

### Chapter 8. Methods

- [49. 检查参数有效性](book/effactive-java-3rd/49.%20检查参数有效性.md)
- [50. 必要时进行防御性拷贝](book/effactive-java-3rd/50.%20必要时进行防御性拷贝.md)
- [51. 仔细设计方法签名](book/effactive-java-3rd/51.%20仔细设计方法签名.md)
- [52. 明智审慎地使用重载](book/effactive-java-3rd/52.%20明智审慎地使用重载.md)
- [53. 明智审慎地使用可变参数](book/effactive-java-3rd/53.%20明智审慎地使用可变参数.md)
- [54. 返回空的数组或集合，不要返回 null](book/effactive-java-3rd/54.%20返回空的数组或集合，不要返回%20null.md)
- [55. 明智审慎地返回 Optional](book/effactive-java-3rd/55.%20明智审慎地返回%20Optional.md)
- [56. 为所有已公开的 API 元素编写文档注释](book/effactive-java-3rd/56.%20为所有已公开的%20API%20元素编写文档注释.md)

### Chapter 9. General Programming

- [57. 最小化局部变量的作用域](book/effactive-java-3rd/57.%20最小化局部变量的作用域.md)
- [58. for-each 循环优于传统 for 循环](book/effactive-java-3rd/58.%20for-each%20循环优于传统%20for%20循环.md)
- [59. 了解并使用库](book/effactive-java-3rd/59.%20了解并使用库.md)
- [60. 若需要精确答案就应避免使用 float 和 double 类型](book/effactive-java-3rd/60.%20若需要精确答案就应避免使用%20float%20和%20double%20类型.md)
- [61. 基本数据类型优于包装类](book/effactive-java-3rd/61.%20基本数据类型优于包装类.md)
- [62. 当使用其他类型更合适时应避免使用字符串](book/effactive-java-3rd/62.%20当使用其他类型更合适时应避免使用字符串.md)
- [63. 当心字符串连接引起的性能问题](book/effactive-java-3rd/63.%20当心字符串连接引起的性能问题.md)
- [64. 通过接口引用对象](book/effactive-java-3rd/64.%20通过接口引用对象.md)
- [65. 接口优于反射](book/effactive-java-3rd/65.%20接口优于反射.md)
- [66. 明智审慎地本地方法](book/effactive-java-3rd/66.%20明智审慎地本地方法.md)
- [67. 明智审慎地进行优化](book/effactive-java-3rd/67.%20明智审慎地进行优化.md)
- [68. 遵守被广泛认可的命名约定](book/effactive-java-3rd/68.%20遵守被广泛认可的命名约定.md)

### Chapter 10. Exceptions

- [69. 只针对异常的情况下才使用异常](book/effactive-java-3rd/69.%20只针对异常的情况下才使用异常.md)
- [70. 对可恢复的情况使用受检异常，对编程错误使用运行时异常](book/effactive-java-3rd/70.%20对可恢复的情况使用受检异常，对编程错误使用运行时异常.md)
- [71. 避免不必要的使用受检异常](book/effactive-java-3rd/71.%20避免不必要的使用受检异常.md)
- [72. 优先使用标准的异常](book/effactive-java-3rd/72.%20优先使用标准的异常.md)
- [73. 抛出与抽象对应的异常](book/effactive-java-3rd/73.%20抛出与抽象对应的异常.md)
- [74. 每个方法抛出的异常都需要创建文档](book/effactive-java-3rd/74.%20每个方法抛出的异常都需要创建文档.md)
- [75. 在细节消息中包含失败一捕获信息](book/effactive-java-3rd/75.%20在细节消息中包含失败一捕获信息.md)
- [76. 保持失败原子性](book/effactive-java-3rd/76.%20保持失败原子性.md)
- [77. 不要忽略异常](book/effactive-java-3rd/77.%20不要忽略异常.md)

### Chapter 11. Concurrency

- [78. 同步访问共享的可变数据](book/effactive-java-3rd/78.%20同步访问共享的可变数据.md)
- [79. 避免过度同步](book/effactive-java-3rd/79.%20避免过度同步.md)
- [80. executor 、task 和 stream 优先于线程](book/effactive-java-3rd/80.%20executor%20、task%20和%20stream%20优先于线程.md)
- [81. 并发工具优于 wait 和 notify](book/effactive-java-3rd/81.%20并发工具优于%20wait%20和%20notify.md)
- [82. 文档应包含线程安全属性](book/effactive-java-3rd/82.%20文档应包含线程安全属性.md)
- [83. 明智审慎的使用延迟初始化](book/effactive-java-3rd/83.%20明智审慎的使用延迟初始化.md)
- [84. 不要依赖线程调度器](book/effactive-java-3rd/84.%20不要依赖线程调度器.md)

### Chapter 12. Serialization

- [85. 优先选择 Java 序列化的替代方案](book/effactive-java-3rd/85.%20优先选择%20Java%20序列化的替代方案.md)
- [86. 非常谨慎地实现 Serializable](book/effactive-java-3rd/86.%20非常谨慎地实现%20Serializable.md)
- [87. 考虑使用自定义的序列化形式](book/effactive-java-3rd/87.%20考虑使用自定义的序列化形式.md)
- [88. 保护性的编写 readObject 方法](book/effactive-java-3rd/88.%20保护性的编写%20readObject%20方法.md)
- [89. 对于实例控制，枚举类型优于 readResolve](book/effactive-java-3rd/89.%20对于实例控制，枚举类型优于%20readResolve.md)
- [90. 考虑用序列化代理代替序列化实例](book/effactive-java-3rd/90.%20考虑用序列化代理代替序列化实例.md)
