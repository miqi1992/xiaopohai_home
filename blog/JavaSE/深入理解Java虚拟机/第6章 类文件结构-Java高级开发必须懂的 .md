##  第6章 类文件结构——Java高级开发必须懂的



> 代码编译的结果从本地机器转变成字节码，是存储格式发展的一小步，却是变成个语言发展的一大步。  

### 6.1 概述

记得在第一节计算机程序课上我的老师就讲过：“计算机只认识 0 和 1，所以我们写的程序需要经编译器翻译成由 0 和 1 构成的二进制格式才能由计算机执行”。10 多年时间过去了，今天的计算机仍然只能识别 0 和 1，但由于最近 10 年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。

### 6.2 无关性的基石

如果计算机的 CPU 指令集只有 x86 一种，操作系统也只有 Windows 一种，那也许 Java 语言就不会出现。Java 在刚刚诞生之时曾经提出过一个非常著名的宣传口号：“一次编写，到处运行（Write Once,Run Anywhere）”，这句话充分表达了软件开发人员对冲破平台界限的渴求。在无时无刻不充满竞争的 IT 领域，不可能只有 Wintel 存在，我们也不希望只有 Wintel 存在，各种不同的硬件体系结构和不同的操作系统肯定会长期并存发展。“与平台无关” 的理想 

最终实现在操作系统的应用层上：Sun 公司以及其他虚拟机提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的 “一次编写，到处运行”。

各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）是构成平台无关性的基石，但本节标题中刻意省略了 “平台” 二字，那是因为笔者注意到虚拟机的另外一种中立特性——语言无关性正越来越被开发者所重视。到目前为止，或许大部分程序员都还认为 Java 虚拟机执行 Java 程序是一件理所当然和天经地义的事情。但在 Java 发展之初，设计者就曾经考虑过并实现了让其他语言运行在 Java 虚拟机之上的可能性，他们在发布规范文档的时候，也刻意把 Java 的规范拆分成了 Java 语言规范《The Java Language Specification》及 Java 虚拟机规范《The Java Virtual Machine Specification》。并且在 1997 年发布的第一版 Java 虚拟机规范中就曾经承诺过：“In the future,we will consider bounded extensions to the Java virtual machine to provide better support for other languages”（在未来，我们会对 Java 虚拟机进行适当的扩展，以便更好地支持其他语言运行于 JVM 之上），当 Java 虚拟机发展到 JDK 1.7～1.8 的时候，JVM 设计者通过 JSR-292 基本兑现了这个承诺。

时至今日，商业机构和开源机构已经在 Java 语言之外发展出一大批在 Java 虚拟机之上运行的语言，如 Clojure、Groovy、JRuby、Jython、Scala 等。使用过这些语言的开发者可能还不是非常多，但是听说过的人肯定已经不少，随着时间的推移，谁能保证日后 Java 虚拟机在语言无关性上的优势不会赶上甚至超越它在平台无关性上的优势呢？

实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与 “Class 文件” 这种特定的二进制文件格式所关联，Class 文件中包含了 Java 虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑，Java 虚拟机规范要求在 Class 文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被 Java 虚拟机所接受的有效的 Class 文件。作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将 Java 虚拟机作为语言的产品交付媒介。例如，使用 Java 编译器可以把 Java 代码编译为存储字节码的 Class 文件，使用 JRuby 等其他语言的编译器一样可以把程序代码编译成 Class 文件，虚拟机并不关心 Class 的来源是何种语言，如图 6-1 所示。

![img](https://xiaopohai-1254153894.cos.ap-chengdu.myqcloud.com/xiaopohai-blog/20170801162752102)

Java 语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此字节码命令所能提供的语义描述能力肯定会比 Java 语言本身更加强大。因此，有一些 Java 语言本身无法有效支持的语言特性不代表字节码本身无法有效支持，这也为其他语言实现一些有别于 Java 的语言特性提供了基础。

### 6.3 Class类文件的结构

解析 Class 文件的数据结构是本章的最主要内容。笔者曾经在前言中阐述过本书的写作风格：力求在保证逻辑准确的前提下，用尽量通俗的语言和案例去讲述虚拟机中与开发关系最为密切的内容。但是，对数据结构方面的讲解不可避免地会比较枯燥，而这部分内容又是了解虚拟机的重要基础之一。如果想比较深入地了解虚拟机，那么这部分是不能不接触的。

在本章关于 Class 文件结构的讲解中，我们将以《Java 虚拟机规范（第 2 版）》（1999 年发布，对应于 JDK 1.4 时代的 Java 虚拟机）中的定义为主线，这部分内容虽然古老，但它所包含的指令、属性是 Class 文件中最重要和最基础的。

注意　任何一个 Class 文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。本章中，笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为 “Class 文件格式”，实际上它并不一定以磁盘文件的形式存在。

Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件之中，中间没有添加任何分隔符，这使得整个 Class 文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用 8 位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个 8 位字节进行存储。

根据 Java 虚拟机规范的规定，Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：**无符号数和表**，后面的解析都要以这两种数据类型为基础，所以这里要先介绍这两个概念。

无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。

表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以 “_info” 结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表，它由表 6-1 所示的数据项构成。 

![img](https://xiaopohai-1254153894.cos.ap-chengdu.myqcloud.com/xiaopohai-blog/20170801163240519)

无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。

本节结束之前，笔者需要再重复讲一下，Class 的结构不像 XML 等描述语言，由于它没有任何分隔符号，所以在表 6-1 中的数据项，无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering,Class 文件中字节序为 Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。接下来我们将一起看看这个表中各个数据项的具体含义。

#### 6.3.1 魔数与Class文件的版本

每个 Class 文件的头 4 个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如 gif 或者 jpeg 等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。Class 文件的魔数的获得很有 “浪漫气息”，值为：0xCAFEBABE（咖啡宝贝？），这个魔数值在 Java 还称做“Oak” 语言的时候（大约是 1991 年前后）就已经确定下了。它还有一段很有趣的历史，据 Java 开发小组最初的关键成员 Patrick Naughton 所说：“我们一直在寻找一些好玩的、容易记忆的东西，选择 0xCAFEBABE 是因为它象征着著名咖啡品牌 Peet’s Coffee 中深受欢迎的 Baristas 咖啡”，这个魔数似乎也预示着日后 “Java” 这个商标名称的出现。

紧接着魔数的 4 个字节存储的是 Class 文件的版本号：第 5 和第 6 个字节是次版本号（Minor Version），第 7 和第 8 个字节是主版本号（Major Version）。Java 的版本号是从 45 开始的，JDK 1.1 之后的每个 JDK 大版本发布主版本号向上加 1（JDK 1.0～1.1 使用了 45.0～45.3 的版本号），高版本的 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的 Class 文件。

紧接着魔数的 4 个字节存储的是 Class 文件的版本号：第 5 和第 6 个字节是次版本号（Minor Version），第 7 和第 8 个字节是主版本号（Major Version）。Java 的版本号是从 45 开始的，JDK 1.1 之后的每个 JDK 大版本发布主版本号向上加 1（JDK 1.0～1.1 使用了 45.0～45.3 的版本号），高版本的 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的 Class 文件。

例如，JDK 1.1 能支持版本号为 45.0～45.65535 的 Class 文件，无法执行版本号为 46.0 以上的 Class 文件，而 JDK 1.2 则能支持 45.0～46.65535 的 Class 文件。现在，最新的 JDK 版本为 1.7，可生成的 Class 文件主版本号最大值为 51.0。

为了讲解方便，笔者准备了一段最简单的 Java 代码（见代码清单 6-1），本章后面的内容都将以这段小程序使用 JDK 1.6 编译输出的 Class 文件为基础来进行讲解。

``` java
package org.fenixsoft.clazz；
public class TestClass{
    private int m；
    public int inc（）{
        return m+1；
    }
}
```

图 6-2 显示的是使用十六进制编辑器 WinHex 打开这个 Class 文件的结果，可以清楚地看见开头 4 个字节的十六进制表示是 0xCAFEBABE，代表次版本号的第 5 个和第 6 个字节值为 0x0000，而主版本号的值为 0x0032，也即是十进制的 50，该版本号说明这个文件是可以被 JDK 1.6 或以上版本虚拟机执行的 Class 文件。

![img](https://xiaopohai-1254153894.cos.ap-chengdu.myqcloud.com/xiaopohai-blog/20170801163853231)

表 6-2 列出了从 JDK 1.1 到 JDK 1.7，主流 JDK 版本编译器输出的默认和可支持的 Class 文件版本号。

![img](https://xiaopohai-1254153894.cos.ap-chengdu.myqcloud.com/xiaopohai-blog/20170801164013108)

#### 6.3.2 常量池

紧接着主次版本号之后的是常量池入口，常量池可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项目之一，同时它还是在 Class 文件中第一个出现的表类型数据项目。

由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的数据，代表常量池容量计数值（constant_pool_count）。与 Java 中语言习惯不一样的是，这个容量计数是从 1 而不是 0 开始的，如图 6-3 所示，常量池容量（偏移地址：0x00000008）为十六进制数 0x0016，即十进制的 22，这就代表常量池中有 21 项常量，索引值范围为 1～21。在 Class 文件格式规范制定之时，设计者将第 0 项常量空出来是有特殊考虑的，这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达 “不引用任何一个常量池项目” 的含义，这种情况就可以把索引值置为 0 来表示。Class 文件结构中只有常量池的容量计数是从 1 开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从 0 开始的。 

![img](https://xiaopohai-1254153894.cos.ap-chengdu.myqcloud.com/xiaopohai-blog/20170801164959785)

常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比较接近于 Java 语言层面的常量概念，如**文本字符串、声明为 final 的常量值**等。而符号引用则属于编译原理方面的概念，包括了下面三类常量：

+ 类和接口的全限定名(Full Qualified Name)
+ 字段的名称和描述符(Descriptor)
+ 方法的名称和描述符

Java 代码在进行 Javac 编译的时候，并不像 C 和 C++ 那样有 “连接” 这一步骤，而是在虚拟机加载 Class 文件的时候进行动态连接。也就是说，在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态连接的内容，在下一章介绍虚拟机类加载过程时再进行详细讲解。

常量池中每一项常量都是一个表，在 JDK 1.7 之前共有 11 种结构各不相同的表结构数据，在 JDK 1.7 中为了更好地支持动态语言调用，又额外增加了 3 种（CONSTANT_MethodHandle_info、CONSTANT_MethodType_info 和 CONSTANT_InvokeDynamic_info，本章不会涉及这 3 种新增的类型，在第 8 章介绍字节码执行和方法调用时，将会详细讲解）。

这 14 种表都有一个共同的特点，就是表开始的第一位是一个 u1 类型的标志位（tag，取值见表 6-3 中标志列），代表当前这个常量属于哪种常量类型。这 14 种常量类型所代表的具体含义见表 6-3。 

![img](https://xiaopohai-1254153894.cos.ap-chengdu.myqcloud.com/xiaopohai-blog/20170801165523531)